{% extends '_layout.jinja2' %}

{% block content %}

  <article>
    <header>
      <h2>The Python Packaging Hell: Files Everywhere (4 / 7)</h2>
      <aside><time datetime="2021-10-28">October 28, 2021</time>, by CourtBouillon</aside>
      <p>
        Python packaging can sometimes be a nightmare. To convince yourself about
        that, you just need a few minutes of drowning into the myriad of usable
        (and used!) files to build or install a packages.
      </p>
    </header>

    {% include 'articles/_python_contents.jinja2' %}

    <section>
      <h3>But Why?</h3>
      <p>
        We can’t say that there is no manual to create Python packages. The
        issue isn’t the lack, but the abundance. You’ll find manuals everywhere,
        more or less old, more or less practical, more or less useful…
        The hardest part isn’t to find one, it’s to read all of them and to
        come across information in each one, until you’ve make your own conviction.
      </p>
      <p>
        Maybe you thought to find in these lines a good summary of what exists,
        but here the sad news: you’ve got here only an additional source to refer
        to if you like one thing or two.
      </p>
      <p>
        That being, it’s not that bad…
      </p>
      <p>
        What is the connection between this introduction and files? Well, it’s
        quite simple. We can’t say there is no configuration file to create
        Python package. The issue isn’t the lack, pat the abundance. You’ll find
        files everywhere, more or less old, more or less practical, more or less
        useful… The hardest part isn’t to find one, it’s to read all of them and
        to come across information in each one, until you’ve make your own
        conviction.
      </p>
      <p>
        (Is it okay, you got it, the connection?)
      </p>

      <figure>
        <img src="{{ url_for('static', filename='images/00015-files-everywhere.jpg')}}" alt='Meme Toy Story "files everywhere"' title="Files everywhere, justice nowhere" />
        <figcaption>
          You want files? You’ll see a lot!
        </figcaption>
      </figure>

      <p>
        We won’t do again the "you have to understand them, people who making
        Python, because Python is old, you can’t change everything suddenly".
        It’s a bit true for this hell of files, but also a bit false.
        <a href="https://github.com/pypa/sample project">The official example</a>
        proposed today by PyPA contains 4 files serving for packages creation
        (<code>setup.py</code>, <code>setup.cfg</code>,
        <code>MANIFEST.in</code> and <code>pyproject.toml</code>).
        If we can understand the envy to cover a maximum of possible solutions,
        we can also condemn the impression of full chaos given to someone who’d
        like to learn.
      </p>
      <p>
        (Reminder: a minimal Rust project contains a <code>Cargo.toml</code> files
        for metadata and a <code>src/main.rs</code> file for the project code.
        Moreover, these two files are automatically created for your with the
        command <code>cargo new</code>.)
      </p>
      <p>
        If it’s true that thinking about all the needs for a configuration file
        since the beginning, on the other hand, it’s more questionable to say we
        have to live with this sad history.
        Unlike other subjects, nothing would prevent us from defining a new
        standard of configuration file. And nothing would prevent us from making
        this standard be able to generate identical packages to existing ones.
        We’d be able to leave the past behind us, with its old files and old
        tools, to only use one file in any case.
        The package creator would adapt to use these new rules, of course, but
        nothing would change for the final user, nor for the tools they’d use.
      </p>
      <p>
        That would be nice, wouldn’t it? It’s time for the good news: it’s
        already what happened. No joke.
      </p>
      <p>
        Now you want to know the rest (yes, it’s totally sneaky and totally
        assumed), we’ll be able to inflict ourselves the full thought process
        to get to the actual situation. What matters, is the path, not the
        destination, no?
      </p>
    </section>

    <section>
      <h3>A Rather Short List</h3>

      <p>
        There is no need to grumble: as each time, we won’t talk about everything
        that had existed to create or install packages. Don’t expect an exhaustive
        list, just a few emblematic files which allow to understand where we
        come from.
      </p>

      <h4><code>setup.py</code></h4>
      <p>
        This file is the first one introduced to handle package creation, it’s
        also the most famous and the most used today, despite its advanced age
        (at least 20 years, this doesn’t make us feel any younger).
      </p>
      <p>
        The idea behind <code>setup.py</code> is quite simple: to set up the whole
        needed configuration to the packages creation and installation, we use
        a Python script defining a set of metadata (the name of the package,
        the list of files to include, etc.) and various commands (create a source
        package, a binary package, install, etc.). To do that, Python offers
        a module called
        <code><a href="https://docs.python.org/3/distutils/index.html#distutils-index">distutils</a></code>,
        containing everything needed to describe these metadata and commands.
        It’s enough to import it in <code>setup.py</code>, to call the right
        functions, and voila.
      </p>
      <p>
        But, as we already saw it several time with tools managing Python
        packages, <code>distutils</code> is rather limited and its features
        aren’t strictly defined. Hurtfully, the code becomes the reference of
        what we can do, and the (legitimate) fear of breaking everything quickly
        prevent to add features or to fix some dysfunction that some
        would have confused with features.
      </p>
      <figure>
        <img src="{{ url_for('static', filename='images/00015-xkcd.png') }}" alt="Mandatory Related XKCD™" title="There are probably children out there holding down spacebar to stay warm in the winter! YOUR UPDATE MURDERS CHILDREN." />
        <figcaption>
          The mandatory <a href="https://xkcd.com/1172/">XKCD</a>
        </figcaption>
      </figure>
      <p>
        Limited by <code>distutils</code>, <code>setup.py</code> may have been
        replaced by an other solution. But we found better: <code>setuptools</code>.
      </p>
      <p>
        <code>setuptools</code> is a module internally using <code>distutils</code>,
        but offering additional features, like a more advanced files to include
        management, the possibility to create Windows executable, and most of all…
        the possibility to define dependencies.
      </p>
      <p>
        We’ll see libraries and tools in detail in the next article, but it’s
        important to understand that <code>setuptools</code> is going to open,
        without realizing, a can of worms.
        As the module is external to Python, it’s much less cluttered by the
        tweezers of its predecessor.
        The new features are added in response to the needs of users, in a
        happy disorganization which at least had the merit of allowing a chaotic
        but large packages distribution.
        The library comes with an executable, <code>easy_install</code>, which
        allow to install a package and its dependencies. It also come with
        the package format "egg" that we saw last time.
      </p>
      <p>
        From the anarchic development of <code>setuptools</code>, it has been
        impossible to correctly specify options and best practices of package
        creation. <code>setup.py</code> has the cons of its pros: being written
        in Python, it allows to use all the full power of the language, for
        something that initially has to be for few lines of metadata and
        installation scripts. Everything that could simply be descriptive
        potentially becomes dynamic when executed. Extensions are proposed,
        dependent or not of <code>setuptools</code>, offering a galaxy of
        possibilities. Scripts are getting bigger, are copying from projects to
        projects without being understood. Part of code fixing dysfunctions for
        different Python versions, <code>distutils</code>
        or <code>setuptools</code> are included in all the <code>setup.py</code>
        of the Earth.
      </p>
      <p>
        And at the end,
        <a href="https://github.com/pandas-dev/pandas/blob/master/setup.py">we get to that</a>.
        Of course, this project needs a lot of configuration and it would be
        difficult to do the same things as this script with less code.
        Of course, it’s quite easy to understand the whole file, furthermore
        nicely written, by hard work.
      </p>
      <p>
        The issue of <code>setup.py</code> isn’t its potential complexity, which
        can be in some cases useful. The real issue it’s that there isn’t, for
        a long time, no simple alternative to create simple packages in pure Python.
        The only way has to be writing code, for thing that could have been
        totally declarative. And who didn’t try to write code, a lot of horrible
        code, even to do simple things? With this stack of horrible code in
        many projects, <code>setuptools</code> has had to include workarounds
        allowing to bypass workarounds set up to bypass issues fixed since.
        <code>setuptools</code> has had to copy and include different functions
        of different Python versions (including its own bugs, of course) to be
        perfectly backward compatible.
        TL;DR: <code>setuptools</code> has become a hellish monster which has
        infected the <code>setup.py</code> of a significant majority of projects.
      </p>

      <h4><code>setup.cfg</code></h4>
      <p>
        Obviously, the idea to set up a declarative format for packages creation
        has came quite quickly, and a solution has been integrated into setuptools:
        <code>setup.cfg</code>.
      </p>
      <p>
        This INI file is nothing else than a different presentation of most of
        the options proposed in Python by <code>setuptools</code>. So we’ll find
        the same disadvantages: same bugs, same options poorly documented, same
        inconsistencies.
      </p>
      <p>
        Mostly, this file isn’t a replacement of <code>setup.py</code>, but an
        extension. We have to keep the script, even almost empty!
        If data are present twice, those from <code>setup.cfg</code> are kept.
      </p>
      <p>
        Why do we need to keep the <code>setup.py</code> file? Just because
        <code>setuptools</code> doesn’t provide an external command to execute
        commands integrated in the script. To generate a source package, we use
        <code>python setup.py sdist</code> which directly execute the script.
      </p>
      <p>
        Everything that could be a detail becomes a major issue. Who would want
        to use a static format, while we can to make a big pile of spaghetti code
        in a script that you still have to keep? How to explain to people
        discovering the language that you have to write a Python file and an INI
        file, while we technically can do without the INI file? You understand:
        we can fight against the call of the code.
      </p>
      <p>
        That explain why <code>setup.cfg</code> isn’t really used today.
        Attached to the two huge ubiquitous ball that are <code>setuptools</code>
        and <code>setup.py</code>, it just brings a small dose of simplicity by
        its declarative side. As long as it’ll be carrying around a heavy and
        sclerosing history, it’ll stay a second choice, an attempt a bit clumsy
        to fix a real issue.
      </p>

      <h4><code>requirements.txt</code></h4>
      <p>
        Here is a file you certainly have already met and used. Praised without
        finesse by second zone tutorials, acclaimed for its simplicity and
        power, used by a lot of famous projects, <code>requirements.txt</code>
        is the star of the installation of dependencies.
      </p>
      <p>
        But well, let’s just go ahead and say it: it has nothing to do with
        packages creation.
      </p>
      <p>
        <code>requirements.txt</code>, is a simple list of packages to install,
        with the possibility to fix versions, sources, branches and
        installation options.
      </p>
      <p>
        It’s often used with <code>pip</code> and just for the installation.
        We can see it as a convenient way to list dependencies, in a format that
        we could directly put in command line but our laziness and our taste for
        line breaks push us to confine it in a file.
      </p>
      <p>
        That’s convenient, in particular for everything we’d like to share in a
        different format than a package. At random: everything but libraries.
        A little unpretentious script? A <code>requirements.txt</code> file.
        A web application? A <code>requirements.txt</code> file.
        A<a href="https://github.com/numpy/numpy">library</a>? Well, ok, still
        some <code>requirements.txt</code> files for the documentation and the
        tests.
      </p>
      <p>
        Yes, we can have a <code>setup.py</code>, a <code>setup.cfg</code> and
        a <code>requirements.txt</code> in the same project. With all their
        friends <code>MANIFEST.in</code>, <code>tox.ini</code>,
        <code>pyproject.toml</code>, <code>pytest.ini</code>, and we ignore some.
        Everyone is doing in its own way getting by as best they can, blithely
        copying on their friends things that seem to work. We’ll always find
        a specific case handling only with one of these files, and simplicity
        will be sacrificed on the altar of sacrosanct feature.
      </p>

      <h4><code>MANIFEST.in</code></h4>
      <p>
        Do you want a very special feature? Including assets in a source package
        is a good example of what a puzzle is.
      </p>
      <p>
        Usually, when distributing a binary package, we do it so the users can
        easily use the code. Packages like wheels are ready-to-use archive, and
        their installation needs nothing more than to be decompress in the right
        folder. These packages are able to contain only the minimum: the code.
        Everything else (documentation, tests, super-cute-little-nice-files
        describing changes…) has nothing to do in it.
      </p>
      <p>
        For source package, it’s different. These packages are useful for a lot
        of people allowing them to do a lot of things: look the code, create
        packages for distribs, test patches, install the library, launch tests…
        So we try to include the maximum of things in the package, almost
        everything in the repository, except what is needed for the continuous
        integration, the versioning configuration, and other small stuff
        polluting our so cute project.
      </p>
      <p>
        To include these files in the source package, in particular when files
        are at the root of the project and not in the same folder as the code,
        we use <code>MANIFEST.in</code>. This umpteenth file comes, properly,
        <a href="https://packaging.python.org/guides/using-manifest-in/">with its own syntax and its own commands</a>.
        And don’t worry: it allows to do, in the same time, things already allowed
        with the other files and things no allowed with the others.
      </p>
      <figure>
        <img src="{{ url_for('static', filename='images/00015-venn.svg') }}" alt="Five-set Venn Diagram" title="Having something so complicated, it’s no luck…" />
        <figcaption>
          Let’s see… With which files can I identify an optional dynamic
          dependence which will only install with Python version 3.7.x on a
          32 bits Windows?
        </figcaption>
      </figure>

      <h4><code>pyproject.toml</code></h4>
      <p>
        We get there.
      </p>
      <p>
        At first sight, <code>pyproject.toml</code> seems to be a direct clone
        of <code>setup.cfg</code>, with a format slightly different and a
        debatable name. Again an other file, again an other format, but what a
        crazy idea?
      </p>
      <p>
        In reality, things are a little bit more complex. The
        <a href="https://www.python.org/dev/peps/pep-0518/">PEP 518</a> which
        had introduced this file is called "Specifying minimum build system
        requirements for python projects". It’s not "And again a new stupid
        format to define metadata of my package" and there are good reasons for
        that.
      </p>
      <p>
        In the list of issues caused by <code>setuptools</code>, there is one
        we haven’t already talk about: <code>setup.py</code> contains the
        dependencies of a package, including the dependencies used to build the
        packages. How to know the dependencies without executing the file? And
        how to execute the file without knowing its dependencies? This issue
        of egg and chicken is problematic for <code>setuptools</code>, but as
        everyone is using it to make packages and that it’s a dependency of
        <code>pip</code>, there’s a good chance that it has already been installed
        with Python. However, if we want to use an other tool, like a
        <code>setuptools</code> extension, things immediately become less easy.
      </p>
      <p>
        The idea of <code>pyproject.toml</code> isn’t to propose a new metadata
        format. The idea is to include, in a simple text file, the dependencies
        needed to build a package. Think about this carefully. A little more.
      </p>
      <p>
        Well, you understand. We’ll be able to get rid of <code>setuptools</code>
        and <code>distutils</code>, at least to build packages. For real.
      </p>
      <p>
        Of course, in simple case, we can still use them. <code>pyproject.toml</code>
        allows to store all metadata we used to store before. It also allows to
        store more complex information, like dependencies and supported Python
        versions, a bit like in <code>setup.cfg</code>, a bit like before.
      </p>
      <p>
        But nothing prevent to use an other tool, which can define itself its own
        configuration options, independent of <code>setuptools</code>.
        Better: the file being specified and well built, it makes way to other
        tools (<code>black</code>, <code>pylint</code>,
        <code>coverage</code>…) to also use this file. And ending the atrocious
        set of confetti of configuration files.
      </p>
      <p>
        Stay one thing to settle: define the entry point of the tool we’re going
        to use to create the package. That’s the job of the
        <a href="https://www.python.org/dev/peps/pep-0517/">PEP 517</a> which
        allows us to free ourselves from <code>setuptools</code>,
        <code>setup.py</code> and all their friends.
      </p>
      <p>
        But… Does it work for real?
      </p>
      <p>
        Yes. We just have to see what tools to use. And it’ll be for the next
        article…
      </p>
    </section>
  </article>

{% endblock content %}
